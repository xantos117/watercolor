<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
        <!-- <link rel="stylesheet" href="simple/simple.min.css"> -->
        <link rel="stylesheet" href="basic.css">
        <style>
			.container {
				position: absolute;
				width: 100%;
				height: 100%;
			}

			.slider {
				position: absolute;
				cursor: ew-resize;

				width: 40px;
				height: 40px;
				background-color: #F32196;
				opacity: 0.7;
				border-radius: 50%;

				top: calc(50% - 20px);
				left: calc(50% - 20px);
			}
		</style>
        <title>Watercolors</title>
        <script id="vertex-shader" type="x-shader/x-vertex">
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
          </script>
          
          <script id="fragment-shader" type="x-shader/x-fragment">
            #include <common>

            varying vec2 vUv;
            uniform vec3 iResolution;
            uniform float iTime;
            uniform vec4 inkColor;
            uniform sampler2D tSource;
            uniform vec2 mousePos;
            uniform float screenWidth;
            uniform float screenHeight;
            uniform bool mDown;
            
            void mainImage( out vec4 fragColor) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 brush = vec4(1.);
                vec4 color1 = inkColor;
                vec4 color2 = vec4(0.0);
                float travelDist = (10. / 1000.) * iTime;

                vec2 diff = (vUv - mousePos)/texel;
                float dist = dot(diff, diff);
                vec4 curColor = texture2D(tSource,vUv);
                vec4 compColor;
                vec2 searchDir;

                compColor = vec4(0);

                for(float i = -1.; i<=1.001;i++){
                    for(float j=-1.;j<=1.001;j++){
                        if(!(i==0. && j==0.)){
                            curColor = texture2D(tSource,vec2(vUv.x + i*texel.x, vUv.y + j*texel.y));
                            compColor.r = max(compColor.r,curColor.r);
                            compColor.g = max(compColor.g,curColor.g);
                            compColor.b = max(compColor.b,curColor.b);
                        }
                    }
                }
                

                if(dist < 50. && mDown) {   
                    fragColor = color1 + curColor;
                }
                else {
                    compColor.r = min(1.,compColor.r);
                    compColor.g = min(1.,compColor.g);
                    compColor.b = min(1.,compColor.b);
                    fragColor = (compColor*0.99);
                }
                
            }
            
            void main() {
                mainImage(gl_FragColor);
            }
          </script>
          <script id="fragment-screen" type="x-shader/x-fragment">
            #include <common>

            varying vec2 vUv;
            uniform vec3 iResolution;
            uniform float iTime;
            uniform vec4 inkColor;
            // (e1,e2,e3,e4)
            uniform sampler2D stVecs;
            // (e5,e6,e7,e8)
            uniform sampler2D diagVecs;
            // (e0, u.x, u.y, rho)
            uniform sampler2D otherVecs;
            uniform sampler2D paperTexture;
            uniform sampler2D reboundTexture;
            uniform sampler2D pigmentTexture1;
            uniform vec2 mousePos;
            uniform float screenWidth;
            uniform float screenHeight;
            uniform int shaderStage;
            uniform bool mDown;
            uniform float omg;
            uniform float rho0;
            uniform float c;
            uniform float alpha;
            uniform float eta;
            uniform bool ink;
            
            // lattice direction vectors
            vec2 e[9] = vec2[9](vec2(0,0),
                        vec2(1,0),
                        vec2(0,1),
                        vec2(-1,0),
                        vec2(0,-1),
                        vec2(1,1),
                        vec2(-1,1),
                        vec2(-1,-1),
                        vec2(1,-1));
            // lattice geometry constants
            float w[9] = float[9](4./9.,1./9.,1./9.,1./9.,1./9.,1./36.,1./36.,1./36.,1./36.);

            float waterEvapRate = 0.01;
            float maxWaterCap = 1.;
            float MAX_KAPPA = 2e20;

            //	<https://www.shadertoy.com/view/Xd23Dh>
            //	by inigo quilez <http://iquilezles.org/www/articles/voronoise/voronoise.htm>
            //

            vec3 hash3( vec2 p ){
                vec3 q = vec3( dot(p,vec2(127.1,311.7)), 
                            dot(p,vec2(269.5,183.3)), 
                            dot(p,vec2(419.2,371.9)) );
                return fract(sin(q)*43758.5453);
            }

            float iqnoise( in vec2 x, float u, float v ){
                vec2 p = floor(x);
                vec2 f = fract(x);
                    
                float k = 1.0+63.0*pow(1.0-v,4.0);
                
                float va = 0.0;
                float wt = 0.0;
                for( int j=-2; j<=2; j++ )
                for( int i=-2; i<=2; i++ )
                {
                    vec2 g = vec2( float(i),float(j) );
                    vec3 o = hash3( p + g )*vec3(u,u,1.0);
                    vec2 r = g - f + o.xy;
                    float d = dot(r,r);
                    float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );
                    va += o.z*ww;
                    wt += ww;
                }
                
                return va/wt;
            }

            //	Classic Perlin 2D Noise 
            //	by Stefan Gustavson
            //
            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

            float cnoise(vec2 P){
                vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
                vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
                Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
                vec4 ix = Pi.xzxz;
                vec4 iy = Pi.yyww;
                vec4 fx = Pf.xzxz;
                vec4 fy = Pf.yyww;
                vec4 i = permute(permute(ix) + iy);
                vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
                vec4 gy = abs(gx) - 0.5;
                vec4 tx = floor(gx + 0.5);
                gx = gx - tx;
                vec2 g00 = vec2(gx.x,gy.x);
                vec2 g10 = vec2(gx.y,gy.y);
                vec2 g01 = vec2(gx.z,gy.z);
                vec2 g11 = vec2(gx.w,gy.w);
                vec4 norm = 1.79284291400159 - 0.85373472095314 * 
                    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
                g00 *= norm.x;
                g01 *= norm.y;
                g10 *= norm.z;
                g11 *= norm.w;
                float n00 = dot(g00, vec2(fx.x, fy.x));
                float n10 = dot(g10, vec2(fx.y, fy.y));
                float n01 = dot(g01, vec2(fx.z, fy.z));
                float n11 = dot(g11, vec2(fx.w, fy.w));
                vec2 fade_xy = fade(Pf.xy);
                vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
                float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
                return 2.3 * n_xy;
            }

            float relax(float f,int i) {
                vec2 u = texture2D(otherVecs,vUv).yz;
                //float alpha = 0.4;
                float rho = texture2D(otherVecs,vUv).a;
                float kap = texture2D(reboundTexture,vUv).b;
                float deu = dot(e[i],u);
                float psi = smoothstep( 0., alpha, rho);
                float f_eq = w[i] *(rho + rho0 * psi * ((3./(c*c))*deu + (9./(2.*(c*c*c*c))) * deu * deu  - (3./(2.*c*c)) * dot(u,u)));
                return (1. - omg) * f + omg * f_eq;
            }

            float relaxExplicit(float f,int i,vec2 u,float rho) {
                float kap = texture2D(reboundTexture,vUv).b;
                float deu = dot(e[i],u);
                float f_eq = w[i] *(rho + rho0 * ((3./(c*c))*deu + (9./(2.*(c*c*c*c))) * deu * deu  - (3./(2.*c*c)) * dot(u,u)));
                return (1. - omg) * f + omg * f_eq;
            }

            void flowPigment(out vec4 fragColor,in sampler2D pigTex) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 stVec = texture2D(stVecs,vUv);
                vec4 diagVec = texture2D(diagVecs,vUv);
                vec4 otherVec = texture2D(otherVecs,vUv);
                vec4 reboundVec = texture2D(reboundTexture,vUv);
                vec4 priorVec = texture2D(pigTex,vUv);

                vec2 diff = (vUv - mousePos)/texel;
                float dist = dot(diff, diff);

                vec2 vel = otherVec.yz;

                float psurf = priorVec.r;
                float pflow = priorVec.g;
                float pfix = priorVec.b;
                float ptemp = 0.;
                float nu = 0.01;
                float toFix = 0.;
                if(dist < 50. && mDown) {   
                    psurf = 1.0;
                }
                
                if(reboundVec.b < 1.){
                    if(otherVec.a + reboundVec.g > 0.){
                        pflow = min((pflow * otherVec.a + psurf * reboundVec.r)/(otherVec.a + reboundVec.r),1.);
                        psurf = max(psurf - (psurf*reboundVec.g/(otherVec.a + reboundVec.g)),0.);
                    }

                    if(reboundVec.b < 10.) {
                        // already wet
                        // perhaps velocity should scale this? 
                        pflow += texture2D(pigTex,vUv - vel).g;
                    }else {
                        for(int i = 1; i<5;i++) {
                            ptemp += stVec[i] * texture2D(pigTex,vUv+e[i]).g;
                        }
                        for(int i = 5;i<9;i++) {
                            ptemp += diagVec[i] * texture2D(pigTex,vUv+e[i]).g;
                        }
                        //if(otherVec.a > 1. && ptemp > eta)
                        ptemp *= (1./otherVec.a);
                        pflow = pflow + ptemp;
                    }
                    //psurf = ptemp;
                    //psurf = max(psurf * reboundVec.r,0.);

                    float wloss = reboundVec.a - otherVec.a;
                    float psi = 0.;
                    if(wloss > 0.)
                        psi = abs((reboundVec.a - otherVec.a)/reboundVec.a);
                    toFix = max(psi * (1.-smoothstep(0.,1.0,otherVec.a)),0.005);
                    //toFix = min(toFix,pflow);
                    pfix = min(pfix + pflow*toFix,1.0);
                    pflow = clamp(pflow-pflow*toFix,0.,1.);
                }

                fragColor = vec4(clamp(psurf,0.,1.),clamp(pflow,0.,1.),clamp(pfix,0.,1.),1.);
            }

            void determineBoundary(out vec4 fragColor) {
                // write out to texture containing values ws, wf, kappa and rho prior
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 otherVec = texture2D(otherVecs,vUv);
                vec2 diff = (vUv - mousePos)/texel;
                float dist = dot(diff, diff);
                if(dist < 50. && mDown) {   
                    fragColor.r = 1.0;
                }else{
                    fragColor.r = max(texture2D(reboundTexture,vUv).r - waterEvapRate, 0.);
                }
                fragColor.g = clamp(fragColor.r,0.,max(maxWaterCap - otherVec.a,0.));
                fragColor.r = max(fragColor.r - fragColor.g, 0.);

                float sumDens = 0.;
                bool block = false;
                for(int i = 1;i<9;i++) {
                    sumDens = texture2D(otherVecs,vUv + e[i]*texel).a;
                    if(sumDens > eta) { 
                        block== true;
                    }
                }
                if(otherVec.a > eta || block) {
                    fragColor.b = iqnoise(100.*vUv, 1., 1.);
                } else {
                    fragColor.b = MAX_KAPPA;
                }
                fragColor.a = otherVec.a;
            }

            void streamInPlus(out vec4 fragColor) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 stVec = texture2D(stVecs,vUv);
                vec4 rebound = texture2D(reboundTexture,vUv);

                vec2 diff = (vUv - mousePos)/texel;
                float dist = dot(diff, diff);

                //if(dist < 50. && mDown) {   
                //    stVec = vec4(1.0);
                //}

                vec4 tex1 = texture2D(stVecs,vUv - e[1]*texel);
                vec4 tex2 = texture2D(stVecs,vUv - e[2]*texel);
                vec4 tex3 = texture2D(stVecs,vUv - e[3]*texel);
                vec4 tex4 = texture2D(stVecs,vUv - e[4]*texel);

                stVec.r = float(rebound.b < 10.) * tex1.r + float(rebound.b > 10.) * tex3.b;
                stVec.g = float(rebound.b < 10.) * tex2.g + float(rebound.b > 10.) * tex4.b;
                stVec.b = float(rebound.b < 10.) * tex3.b + float(rebound.b > 10.) * tex1.b;
                stVec.a = float(rebound.b < 10.) * tex4.a + float(rebound.b > 10.) * tex2.b;

                fragColor = stVec;
            }

            void streamInX(out vec4 fragColor) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 diagVec = texture2D(diagVecs,vUv);
                vec4 rebound = texture2D(reboundTexture,vUv);

                vec2 diff = (vUv - mousePos)/texel;
                float dist = dot(diff, diff);

                //if(dist < 50. && mDown) {   
                //    diagVec = vec4(1.0);
                //}

                for(int i = 0;i<4;i++){
                    diagVec[i] = texture2D(diagVecs,vUv - e[i+5]*texel)[i];
                }
                vec4 tex1 = texture2D(diagVecs,vUv - e[5]*texel);
                vec4 tex2 = texture2D(diagVecs,vUv - e[6]*texel);
                vec4 tex3 = texture2D(diagVecs,vUv - e[7]*texel);
                vec4 tex4 = texture2D(diagVecs,vUv - e[8]*texel);

                diagVec.r = float(rebound.b < 10.) * tex1.r + float(rebound.b > 10.) * tex3.b;
                diagVec.g = float(rebound.b < 10.) * tex2.g + float(rebound.b > 10.) * tex4.b;
                diagVec.b = float(rebound.b < 10.) * tex3.b + float(rebound.b > 10.) * tex1.b;
                diagVec.a = float(rebound.b < 10.) * tex4.a + float(rebound.b > 10.) * tex2.b;

                fragColor = diagVec;
            }

            void updateDensVel(out vec4 fragColor) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 stVec = texture2D(stVecs,vUv);
                vec4 diagVec = texture2D(diagVecs,vUv);
                vec4 otherVec = texture2D(otherVecs,vUv);

                vec2 diff = (vUv - mousePos)/texel;
                float dist = dot(diff, diff);

                float rho = 0.;
                if(dist < 50. && mDown) {   
                    rho = 1.0;
                    otherVec.r = 1.0;
                }
                else {
                    rho = stVec.r + stVec.g + stVec.b + stVec.a + diagVec.r + diagVec.g + diagVec.b + diagVec.a + otherVec.r;
                    //rho *= 0.9;
                }

                vec2 u = e[1] * stVec.r + e[2] * stVec.g + e[3] * stVec.b + e[4] * stVec.a + e[5] * diagVec.r + e[6] * diagVec.g + e[7] * diagVec.b + e[8] * diagVec.a; 
                u *= (1./rho0);

                fragColor = vec4(relaxExplicit(otherVec.r,0,u,rho), u.x, u.y, rho);
            }

            void relaxPlus(out vec4 fragColor) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 stVec = texture2D(stVecs,vUv);
                //vec4 diagVecs = texture2D(diagVecs,vUv);
                //vec4 otherVecs = texture2D(otherVecs,vUv);

                stVec.r = relax(stVec.r,1);
                stVec.g = relax(stVec.g,2);
                stVec.b = relax(stVec.b,3);
                stVec.a = relax(stVec.a,4);

                fragColor = stVec;
            }

            void relaxX(out vec4 fragColor) {
                vec2 texel = vec2(1.0/screenWidth, 1.0/screenHeight);
                vec4 stVec = texture2D(stVecs,vUv);
                vec4 diagVec = texture2D(diagVecs,vUv);
                vec4 otherVec = texture2D(otherVecs,vUv);

                diagVec.r = relax(diagVec.r,5);
                diagVec.g = relax(diagVec.g,6);
                diagVec.b = relax(diagVec.b,7);
                diagVec.a = relax(diagVec.a,8);

                fragColor = diagVec;
            }

            void drawToScreen(out vec4 fragColor) {
                vec4 otherVec = texture2D(otherVecs,vUv);
                vec4 paperVec = texture2D(paperTexture,vUv);
                vec4 boundVec = texture2D(reboundTexture,vUv);
                vec4 redVec = texture2D(pigmentTexture1,vUv);
                float sumRed = redVec.r + redVec.g + redVec.b;
                float intens = clamp(sumRed/3.,0.,1.);
                fragColor = vec4(intens,0.,0.,intens);
                //if(sumRed<0.01) {
                //    fragColor = vec4(0.8,0.8,0.8,1.);
                //}else {
                //    fragColor = vec4(intens,0.,0.,1.);
                //    //fragColor = redVec;
                //}
                //vec4 lColor = mix(paperVec+vec4(1.),vec4(vec3(0.),1.),intens);
                //fragColor = colormap(boundVec.b);
            }
            
            void main() {
                //vec4 rPig = texture2D(pigmentTexture1,vUv);
                switch (shaderStage) {
                    case 0:
                        streamInPlus(gl_FragColor);
                        break;
                    case 1:
                        streamInX(gl_FragColor);
                        break;
                    case 2:
                        updateDensVel(gl_FragColor);
                        break;
                    case 3:
                        relaxPlus(gl_FragColor);
                        break;
                    case 4: 
                        relaxX(gl_FragColor);
                        break;
                    case 5:
                        determineBoundary(gl_FragColor);
                        break;
                    case 6:
                        flowPigment(gl_FragColor,pigmentTexture1);
                        break;
                    default:
                        drawToScreen(gl_FragColor);
                        break;
                }
            }
          </script>
          
    </head>

    <body>    
        <div class="container">
			<div class="slider"></div>
		</div>
        <script type="module" src="bundle.js"></script>
    </body>
</html>